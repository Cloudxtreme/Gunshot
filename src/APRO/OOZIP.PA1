type
  FreeListArray = array[257..8192] of Word;
  FreeListPtr = ^FreeListArray;

const
  LocalHeaderSig    : Longint = $04034B50;  {signatures}
  CentralDirHeadSig : Longint = $02014B50;
  CentralDirTailSig : Longint = $06054B50;

  MaxUnZipVer       = 20;                                              {!!.01}

  MinCodeBits = 9;      {Starting code size}
  MaxCodeBits = 13;     {Maximum code size}
  TableSize   = 8191;   {Table holds 4K entries}
  Special     = 256;    {Special function code}
  CodeIncSize = 1;      {Indicates jump in code size}
  ClearCode   = 2;      {Indicates code table cleared}
  FirstFree   = 257;    {First available table entry}
  Unused      = -1;     {Prefix code for unused table entry}

var
  NewZip      : File;             {File var for updating the ZIP}
  CDT         : CentralDirTail;   {Global central dir tail}
  CDTComment  : CommentPtr;       {Global ZIP file comment}
  NextFree    : Word;             {FreeList index}
  ClearList   : array[0..1023] of Byte;  {Used for adaptive resets}
  FreeList    : FreeListPtr;      {Used after adaptive resets}
  CodeSize    : Byte;             {Bit size of current codes}
  MaxCode     : Word;             {Largest code in CodeSize bits}
  BitBuffer   : LongInt;          {32bit buffer for handling bit output}
  BitsUsed    : Byte;             {Number of bits currently in bit buffer}
  CompressSize: LongInt;          {Size of compressed file}
  Prefix      : Word;             {Current prefix character}
  InFile      : File;             {File being compressed}
  PendingClear: Boolean;          {True when string table needs to be cleared}
  ShowProg    : Boolean;          {Convenient boolean for show prog testing}
  BytesOut    : LongInt;          {Bytes written so far}
  OrigFileSize: LongInt;          {Original size of current file}
  {SPFAddr     : Pointer;}        {Gobal ShowProgress ptr for inline reference}
  {SPFSelf     : Pointer;}        {Also for convenient inline reference}

  constructor ZipNode.Init(var CDH   : CentralDirHead;
                           var CP    : CommentPtr;
                           var FName : PathStr);
    {-Initialize node}
  begin
    znNext   := nil;
    znCDH    := CDH;
    znFName  := FName;
    znCP     := CP;
    znEP     := nil;
    znTagged := True;
  end;

  destructor ZipNode.Done;
    {-Destroy node}
  begin
    FreeMemCheck(znCP, znCDH.CommentLength);
    FreeMemCheck(znEP, znCDH.ExtraLength);
  end;

  procedure ZipNode.SetTag(On : Boolean);
    {-Tag/untag this node}
  begin
    znTagged := On;
  end;

  constructor ZipFileList.Init;
    {-Initialize list}
  begin
    zfHead := nil;
    zfTail := nil;
    zfCount := 0;
  end;

  destructor ZipFileList.Done;
    {-Destroy list}
  var
    CurP, NextP : ZipNodePtr;
  begin
    CurP := zfHead;
    while CurP <> nil do begin
      NextP := CurP^.znNext;
      Dispose(CurP, Done);
      CurP := NextP;
    end;
  end;

  function ZipFileList.Append(var CDH   : CentralDirHead;
                              var CP    : CommentPtr;
                              var FName : PathStr) : Boolean;
    {-Add a node to the list}
  var
    ZNP : ZipNodePtr;
  begin
    New(ZNP, Init(CDH, CP, FName));
    if ZNP = nil then
      Append := False
    else begin
      Append := True;
      if zfHead = nil then begin
        zfHead := ZNP;
        zfTail := ZNP;
      end
      else begin
        zfTail^.znNext := ZNP;
        zfTail := ZNP;
      end;
      Inc(zfCount);
    end;
  end;

  procedure ZipFileList.Delete(ZNP : ZipNodePtr);
    {-Delete the specified node from the ZipFileList}
  var
    P, LP : ZipNodePtr;
  begin
    LP := nil;
    P := zfHead;
    while P <> nil do
      if P = ZNP then begin
        if LP = nil then
          zfHead := P^.znNext
        else
          LP^.znNext := P^.znNext;
        Dec(zfCount);
        FreeMemCheck(P, SizeOf(ZipNode));
        Exit;
      end
      else begin
        LP := P;
        P := P^.znNext;
      end;
  end;

  constructor UnZip.Init(FName : PathStr);
    {-Initialize the archive and open the input file}
  begin
    if not Archive.Init(FName) then
      Fail;
    uzTailPos     := -1;
    @uzOK         := nil;
    @uzShowZip    := nil;
    @uzShowMethod := nil;
    @uzSuccess    := nil;
    @uzProgress   := nil;

    {check for valid ZIP file}
    uzFindCentralDirTail;
    if arError <> ecOk then begin
      ArchiveStatus := arError;
      Done;
      Fail;
    end;
  end;

  procedure UnZip.Extract(Mask : PathStr);
    {-Extract all files matching Mask}
  var
    FML : FileMaskList;
  begin
    FML.Init;
    if not FML.Append(Mask) then
      arError := epFatal+ecOutOfMemory
    else
      ExtractFileMaskList(FML);
    FML.Done;
  end;

  procedure UnZip.ExtractFileMaskList(var FML : FileMaskList);
    {-Extract all files matching one of the masks in specified list}
  var
    ZFL : ZipFileList;
    SaveOptions : Word;
  begin
    ZFL.Init;
    SaveOptions := arOptions;
    ClearFlag(arOptions, arReadFileComments);
    BuildZipFileList(ZFL, FML);
    arOptions := SaveOptions;
    if arError = ecOk then
      ExtractZipFileList(ZFL);
    ZFL.Done;
  end;

  procedure UnZip.BuildZipFileList(var ZFL : ZipFileList; var FML : FileMaskList);
    {-Build a list of ZIPped files to be unzipped}
  var
    Sig : LongInt;
    CP  : CommentPtr;
    EP  : ExtraPtr;
    CDH : CentralDirHead;
    OutName : PathStr;
    Finished : Boolean;
  begin
    {find the tail of the central directory}
    arError := ecOk;
    uzFindCentralDirTail;
    if arError <> ecOk then
      Exit;

    {read the tail of the central directory}
    uzReadCentralDirTail(CDT, CP);
    if arError <> ecOk then begin
      FreeMemCheck(CP, CDT.CommentLength);
      Exit;
    end;

    {show name, zip file comment, if any and requested}
    if arOptionsAreOn(arReadArcComments) then
      ShowComments(CP, CDT.CommentLength)
    else
      ShowComments(nil, 0);

    {Save the comment if compressing, else dispose of it}
    if arOptionsAreOn(arReadExtraField) then
      CDTComment := CP
    else
      FreeMemCheck(CP, CDT.CommentLength);

    {find the start of the central directory}
    uzFindCentralDir(CDT);

    Finished := False;
    while (arError = ecOk) and not Finished do begin
      {read next signature}
      uzReadSignature(Sig);

      {was there an error?}
      if arError = ecOk then
        if (Sig = CentralDirHeadSig) then begin
          uzReadCentralDirHead(CDH, OutName, CP, EP);
          if arError = ecOk then begin
            if FML.Match(OutName) then begin                           {!!.02}
              if not ZFL.Append(CDH, CP, OutName) then                 {!!.02}
                arError := ecOutOfMemory;                              {!!.02}
            end else begin                                             {!!.02}
              {No match. Free comment and extra pointers}              {!!.02}
              FreeMemCheck(CP, CDH.CommentLength);                     {!!.02}
              FreeMemCheck(EP, CDH.ExtraLength);                       {!!.02}
            end;                                                       {!!.02}
          end;                                                         {!!.02}
        end else if (Sig = CentralDirTailSig) then                     {!!.02}
          Finished := True
        else
          arError := ecBadFileFormat;
    end;

    if (arError = ecOk) and (ZFL.zfCount = 0) then
      arError := epNonFatal+ecNoMatchingFiles
    else if arError <> ecOk then
      Inc(arError, epFatal);
  end;

  procedure UnZip.ExtractZipFileList(var ZFL : ZipFileList);
    {-Extract all files in the zip file list}
  var
    ZNP : ZipNodePtr;
    I : Word;
    Name : PathStr;
  begin
    ZNP := ZFL.zfHead;
    while ZNP <> nil do
      with ZNP^ do begin
        {is it OK to write this file?}
        if znTagged and                                                {!!.03}
          ((znCDH.ExternalAttrs and Directory) = 0) then begin         {!!.03}
          Name := arActualName(znFName);
          if OkToWrite(ZNP, Name) then begin
            {show what we're doing}
            ShowMethod(ZNP, Name);

            {try to create the output file}
            uzExtractFile(znCDH, Name);

            {report error if we failed}
            I := arError;
            if not ExtractSuccess(ZNP, Name) then begin
              arError := I;
              Exit;
            end
            else
              arError := ecOk;
          end;
        end;
        ZNP := ZNP^.znNext;
      end;
  end;

  procedure UnZip.uzSkipData(N : LongInt);
    {-Skip the next N bytes of data in arFile}
  var
    Regs : Registers;
    Handle : Word absolute arFile;
  begin
    arError := ecOk;
    if N > 0 then
      with Regs do begin
        AX := $4201;         {move file pointer function, relative to current pos}
        BX := Handle;        {file handle}
        CX := LH(N).H;       {CX has high word of delta}
        DX := LH(N).L;       {DX has low word}
        MsDos(Regs);
        if Odd(Flags) then
          arError := AX;
      end;
  end;

  procedure UnZip.uzReadSignature(var Sig : LongInt);
    {-Read a signature from the ZIP file and return IoResult}
  begin
    BlockRead(arFile, Sig, SizeOf(Sig));
    arError := IoResult;
  end;

  procedure UnZip.uzReadString(L : Word; var S : String; Max : Byte);
    {-Read a string of length L from the ZIP file}
  var
    SLen : Byte absolute S;
  begin
    {read at most Max bytes into S}
    if L < Max then
      SLen := L
    else
      SLen := Max;
    BlockRead(arFile, S[1], SLen);
    arError := IoResult;

    {if we truncated the string, skip over the bytes we didn't read}
    if arError = ecOk then
      uzSkipData(SLen-L);
  end;

  procedure UnZip.uzReadLocalHeader(var LH : LocalHeader; var FName : PathStr);
    {-Read a local header from the ZIP file}
  begin
    BlockRead(arFile, LH, SizeOf(LH));
    arError := IoResult;
    if arError = ecOk then begin
      uzReadString(LH.NameLength, FName, SizeOf(PathStr)-1);
      if arError = ecOk then
        uzSkipData(LH.ExtraLength);
    end;
  end;

  procedure UnZip.uzReadOneComment(var CP : CommentPtr; Len : Word);
    {-Allocate a CommentPtr and read a Comment into it}
  begin
    if not GetMemCheck(CP, Len) then
      arError := ecOutOfMemory
    else begin
      BlockRead(arFile, CP^, Len);
      arError := IoResult;
      if arError <> ecOk then begin
        FreeMem(CP, Len);
        CP := nil;
      end;
    end;
  end;

  procedure UnZip.uzReadOneExtraField(var EP : ExtraPtr; Len : Word);
    {-Allocate an ExtraPtr and read an ExtraField into it}
  begin
    if Len <> 0 then begin
      if not GetMemCheck(EP, Len) then
        arError := ecOutOfMemory
      else begin
        BlockRead(arFile, EP^, Len);
        arError := IoResult;
        if arError <> ecOk then begin
          FreeMem(EP, Len);
          EP := nil;
        end;
      end;
    end;
  end;

  procedure UnZip.uzReadCentralDirHead(var CDH   : CentralDirHead;
                                       var FName : PathStr;
                                       var CP    : CommentPtr;
                                       var EP    : ExtraPtr);
    {-Read a central directory header}
  begin
    CP := nil;
    BlockRead(arFile, CDH, SizeOf(CDH));
    arError := IoResult;
    if arError = ecOk then
      uzReadString(CDH.NameLength, FName, SizeOf(PathStr)-1);
    if arError = ecOk then
      if arOptionsAreOn(arReadExtraField) then
        uzReadOneExtraField(EP, CDH.ExtraLength)
      else
        uzSkipData(CDH.ExtraLength);
    if (arError = ecOk) and (CDH.CommentLength <> 0) then
      if not arOptionsAreOn(arReadFileComments) then
        uzSkipData(CDH.CommentLength)
      else
        uzReadOneComment(CP, CDH.CommentLength);
  end;

  procedure UnZip.uzReadCentralDirTail(var CDT : CentralDirTail; var CP : CommentPtr);
    {-Read the "header" that marks the end of the central directory}
  begin
    CP := nil;
    BlockRead(arFile, CDT, SizeOf(CDT));
    arError := IoResult;
    if (arError = ecOk) and (CDT.CommentLength <> 0) then
      {Read the archive comment so, if needed, we can write it out}
      uzReadOneComment(CP, CDT.CommentLength);
  end;

  procedure UnZip.uzFindCentralDir(var CDT : CentralDirTail);
    {-Move file pointer to beginning of central directory}
  begin
    Seek(arFile, CDT.CentralDirOfs);
    arError := IoResult;
  end;

  procedure UnZip.uzFindCentralDirTail;
    {-Move file pointer to tail of central directory}
  label
    AlreadyKnown;
  const
    IdSize    = 4;                {SizeOf(LongInt)}
    BufSize   = 64 {512};
    BufLessId = 60 {508};         {BufSize-IdSize}
  var
    ID, FS, P : LongInt;
    BytesRead, BufPos : Word;
    Buf : array[1..BufSize] of Byte;
  begin
    if uzTailPos <> -1 then
      goto AlreadyKnown;

    {figure out where to start searching}
    FS := FileSize(arFile);
    if FS <= BufSize {512} then
      P := 0
    else
      P := FS-BufSize {512};

    {seek to starting point for search}
    Seek(arFile, P);
    arError := IoResult;
    if arError <> ecOk then
      Exit;

    {fill the buffer}
    BlockRead(arFile, Buf, BufSize, BytesRead);
    arError := IoResult;
    if arError <> ecOk then
      Exit;

    {search the buffer for the ID}
    Id := CentralDirTailSig;
    BufPos := Search(Buf, BytesRead, ID, IdSize);

    {loop until Id found or beginning of file reached}
    while (BufPos = $FFFF) and (P > 0) do begin
      {move the front end of the buffer to the tail of the buffer}
      Move(Buf, Buf[BufLessId+1], IdSize);

      {back up the file pointer}
      Dec(P, BufLessId);
      if P < 0 then
        P := 0;
      Seek(arFile, P);
      arError := IoResult;
      if arError <> ecOk then
        Exit;

      {fill the front part of the buffer}
      BlockRead(arFile, Buf, BufLessId, BytesRead);
      arError := IoResult;
      if arError <> ecOk then
        Exit;

      if BytesRead < BufLessId then
        {move things forward if necessary}
        Move(Buf[BufLessId+1], Buf[BytesRead+1], IdSize);

      if BytesRead > 0 then begin
        {adjust BytesRead to indicate the actual number of bytes in the buffer}
        Inc(BytesRead, IdSize);
        {search the buffer for Id}
        BufPos := Search(Buf, BytesRead, ID, IdSize);
      end;
    end;

    if BufPos = $FFFF then begin
      arError := epFatal+ecNotAZipFile;
      Exit;
    end
    else
      uzTailPos := P+BufPos+IdSize;

  AlreadyKnown:

    {position file pointer just beyond the ID}
    Seek(arFile, uzTailPos);
    arError := IoResult;
  end;

  procedure Crc32Table; assembler;
  asm
    DD      000000000h, 077073096h, 0EE0E612Ch, 0990951BAh
    DD      0076DC419h, 0706AF48Fh, 0E963A535h, 09E6495A3h
    DD      00EDB8832h, 079DCB8A4h, 0E0D5E91Eh, 097D2D988h
    DD      009B64C2Bh, 07EB17CBDh, 0E7B82D07h, 090BF1D91h
    DD      01DB71064h, 06AB020F2h, 0F3B97148h, 084BE41DEh
    DD      01ADAD47Dh, 06DDDE4EBh, 0F4D4B551h, 083D385C7h
    DD      0136C9856h, 0646BA8C0h, 0FD62F97Ah, 08A65C9ECh
    DD      014015C4Fh, 063066CD9h, 0FA0F3D63h, 08D080DF5h
    DD      03B6E20C8h, 04C69105Eh, 0D56041E4h, 0A2677172h
    DD      03C03E4D1h, 04B04D447h, 0D20D85FDh, 0A50AB56Bh
    DD      035B5A8FAh, 042B2986Ch, 0DBBBC9D6h, 0ACBCF940h
    DD      032D86CE3h, 045DF5C75h, 0DCD60DCFh, 0ABD13D59h
    DD      026D930ACh, 051DE003Ah, 0C8D75180h, 0BFD06116h
    DD      021B4F4B5h, 056B3C423h, 0CFBA9599h, 0B8BDA50Fh
    DD      02802B89Eh, 05F058808h, 0C60CD9B2h, 0B10BE924h
    DD      02F6F7C87h, 058684C11h, 0C1611DABh, 0B6662D3Dh
    DD      076DC4190h, 001DB7106h, 098D220BCh, 0EFD5102Ah
    DD      071B18589h, 006B6B51Fh, 09FBFE4A5h, 0E8B8D433h
    DD      07807C9A2h, 00F00F934h, 09609A88Eh, 0E10E9818h
    DD      07F6A0DBBh, 0086D3D2Dh, 091646C97h, 0E6635C01h
    DD      06B6B51F4h, 01C6C6162h, 0856530D8h, 0F262004Eh
    DD      06C0695EDh, 01B01A57Bh, 08208F4C1h, 0F50FC457h
    DD      065B0D9C6h, 012B7E950h, 08BBEB8EAh, 0FCB9887Ch
    DD      062DD1DDFh, 015DA2D49h, 08CD37CF3h, 0FBD44C65h
    DD      04DB26158h, 03AB551CEh, 0A3BC0074h, 0D4BB30E2h
    DD      04ADFA541h, 03DD895D7h, 0A4D1C46Dh, 0D3D6F4FBh
    DD      04369E96Ah, 0346ED9FCh, 0AD678846h, 0DA60B8D0h
    DD      044042D73h, 033031DE5h, 0AA0A4C5Fh, 0DD0D7CC9h
    DD      05005713Ch, 0270241AAh, 0BE0B1010h, 0C90C2086h
    DD      05768B525h, 0206F85B3h, 0B966D409h, 0CE61E49Fh
    DD      05EDEF90Eh, 029D9C998h, 0B0D09822h, 0C7D7A8B4h
    DD      059B33D17h, 02EB40D81h, 0B7BD5C3Bh, 0C0BA6CADh
    DD      0EDB88320h, 09ABFB3B6h, 003B6E20Ch, 074B1D29Ah
    DD      0EAD54739h, 09DD277AFh, 004DB2615h, 073DC1683h
    DD      0E3630B12h, 094643B84h, 00D6D6A3Eh, 07A6A5AA8h
    DD      0E40ECF0Bh, 09309FF9Dh, 00A00AE27h, 07D079EB1h
    DD      0F00F9344h, 08708A3D2h, 01E01F268h, 06906C2FEh
    DD      0F762575Dh, 0806567CBh, 0196C3671h, 06E6B06E7h
    DD      0FED41B76h, 089D32BE0h, 010DA7A5Ah, 067DD4ACCh
    DD      0F9B9DF6Fh, 08EBEEFF9h, 017B7BE43h, 060B08ED5h
    DD      0D6D6A3E8h, 0A1D1937Eh, 038D8C2C4h, 04FDFF252h
    DD      0D1BB67F1h, 0A6BC5767h, 03FB506DDh, 048B2364Bh
    DD      0D80D2BDAh, 0AF0A1B4Ch, 036034AF6h, 041047A60h
    DD      0DF60EFC3h, 0A867DF55h, 0316E8EEFh, 04669BE79h
    DD      0CB61B38Ch, 0BC66831Ah, 0256FD2A0h, 05268E236h
    DD      0CC0C7795h, 0BB0B4703h, 0220216B9h, 05505262Fh
    DD      0C5BA3BBEh, 0B2BD0B28h, 02BB45A92h, 05CB36A04h
    DD      0C2D7FFA7h, 0B5D0CF31h, 02CD99E8Bh, 05BDEAE1Dh
    DD      09B64C2B0h, 0EC63F226h, 0756AA39Ch, 0026D930Ah
    DD      09C0906A9h, 0EB0E363Fh, 072076785h, 005005713h
    DD      095BF4A82h, 0E2B87A14h, 07BB12BAEh, 00CB61B38h
    DD      092D28E9Bh, 0E5D5BE0Dh, 07CDCEFB7h, 00BDBDF21h
    DD      086D3D2D4h, 0F1D4E242h, 068DDB3F8h, 01FDA836Eh
    DD      081BE16CDh, 0F6B9265Bh, 06FB077E1h, 018B74777h
    DD      088085AE6h, 0FF0F6A70h, 066063BCAh, 011010B5Ch
    DD      08F659EFFh, 0F862AE69h, 0616BFFD3h, 0166CCF45h
    DD      0A00AE278h, 0D70DD2EEh, 04E048354h, 03903B3C2h
    DD      0A7672661h, 0D06016F7h, 04969474Dh, 03E6E77DBh
    DD      0AED16A4Ah, 0D9D65ADCh, 040DF0B66h, 037D83BF0h
    DD      0A9BCAE53h, 0DEBB9EC5h, 047B2CF7Fh, 030B5FFE9h
    DD      0BDBDF21Ch, 0CABAC28Ah, 053B39330h, 024B4A3A6h
    DD      0BAD03605h, 0CDD70693h, 054DE5729h, 023D967BFh
    DD      0B3667A2Eh, 0C4614AB8h, 05D681B02h, 02A6F2B94h
    DD      0B40BBE37h, 0C30C8EA1h, 05A05DF1Bh, 02D02EF8Dh
  end;

  procedure UpdateCRC(var CRC : LongInt; var Buffer; Len : Word); far;
    {-Update 32-bit CRC based on first Len bytes in Buffer}
  begin
    asm
      MOV     CX,Len                  {CX = Len}
      JCXZ    @@ucDone                {nothing to do if Len = 0}

      PUSH    DS                      {save DS}
      LDS     DI,CRC                  {DS:DI => CRC}
      MOV     AX,DS:[DI]
      MOV     DX,DS:[DI+2]            {DX:AX = CRC}
      LDS     SI,Buffer               {DS:SI => Buffer}
      CLD                             {go forward}
  @@ucNext:
      MOV     BL,AL                   {BL = AL}
      LODSB                           {load next byte into AL}
      XOR     BL,AL                   {XOR BL with AL}
      XOR     BH,BH                   {use result as index into DWORD table}
      SHL     BX,1
      SHL     BX,1
      MOV     AL,AH                   {shift DX:AX left 8 bits}
      MOV     AH,DL
      MOV     DL,DH
      XOR     DH,DH
      ADD     BX,OFFSET Crc32Table
      XOR     AX,CS:[BX]              {XOR with CRC table entry}
      XOR     DX,CS:[BX+2]
      LOOP    @@ucNext                {repeat}

      LES     DI,CRC                  {ES:DI => CRC}
      STOSW                           {store low word}
      MOV     AX,DX                   {store high word}
      STOSW
      POP     DS                      {restore DS}
  @@ucDone:
    end;
  end;

{------------ file decompression -----------}

type
  Follower =                      {used to expand reduced files}
    record
      Size : Byte;                {size of follower set}
      FSet : array[0..31] of Byte; {follower set}
    end;
  FollowerSets = array[0..255] of Follower;

  SfEntryPtr = ^SfEntry;
  SfEntry =                       {entry in a Shannon-Fano tree}
    record
      case Byte of
        0 : (Code : Word; Value, BitLength : Byte);
        1 : (L : LongInt);
    end;
  SfTree =
    record                        {a Shannon-Fano tree}
      Entries : Integer;
      MaxLength : Integer;
      Entry : array[0..256] of SfEntry;
    end;

  ByteArray4K = array[1..4096] of Byte;
  ByteArray8K = array[0..8192] of Byte;
  IntArray8K  = array[0..8192] of Integer;

var
  gCDH : CentralDirHead;          {a central directory header}

  InBuf : ^ByteArray4K;           {input buffer}
  InPos : Integer;                {current position in input buffer}
  InCnt : Integer;                {number of bytes in input buffer}
  InLeft : LongInt;               {bytes remaining in compressed input file}
  InEof  : Boolean;               {set when InLeft = 0}
  CurByte : Byte;                 {current input byte}
  BitsLeft : Byte;                {bits left to process in CurByte}

  OutBuf : ^ByteArray8K;          {output buffer}
  OutSent : LongInt;              {number of bytes sent to output buffer}
  OutPos : Integer;               {current position in output buffer}

  OutF : file;                    {output file}

  Factor : Byte;                  {reduction factor}
  FactorMask : Byte;              {bit mask to use based on Factor}
  Followers : ^FollowerSets;      {array of follower sets}
  State : Integer;                {used while processing reduced files}
  V : Integer;                    {"}
  Len : Integer;                  {"}

  PrefixTable : ^IntArray8K;      {used while processing shrunk files}
  SuffixTable : ^ByteArray8K;     {"}
  HeadTable : ^IntArray8K;        {used while shrinking files}
  Stack : ^ByteArray8K;           {"}
  StackIndex : Integer;           {"}

  LitTree : ^SfTree;              {Literal tree}
  LengthTree : ^SfTree;           {Length tree}
  DistanceTree : ^SfTree;         {Distance tree}
  MinMatchLength : Integer;       {minimum match length}
  DictBits : Integer;             {number of bits used in sliding dictionary}


  procedure UnZip.uzReadNext;
    {-Read next byte from input stream}
  var
    L : LongInt;
  begin
    {do we still have a byte buffered?}
    if InPos <= InCnt then begin
      {get next byte out of buffer and advance position counter}
      CurByte := InBuf^[InPos];
      Inc(InPos);
    end
    {are there any left to read?}
    else if (InLeft = 0) then begin
      {we're done}
      InEof := True;
      InPos := InCnt+1;
    end
    else begin
      {refresh the buffer}
      if InLeft > SizeOf(InBuf^) then
        L := SizeOf(InBuf^)
      else
        L := InLeft;
      BlockRead(arFile, InBuf^, L, InCnt);
      arError := IoResult;
      InEof := (arError <> ecOk);

      {decrement count of bytes left to go}
      Dec(InLeft, InCnt);

      {load first byte in buffer and set position counter}
      CurByte := InBuf^[1];
      InPos := 2;
    end;
  end;

  function UnZip.uzReadBits(Bits : Byte) : Integer;
    {-Read the specified number of bits}
  var
    SaveCurByte, Delta, SaveBitsLeft : Byte;
  begin
    {read next byte if we're out of bits}
    if BitsLeft = 0 then begin
      uzReadNext;
      BitsLeft := 8;
    end;

    if (Bits < BitsLeft) then begin
      inline(
        $8A/$4E/<Bits/         {mov cl,[bp+<Bits]     ;cl = Bits}
        $28/$0E/>BitsLeft/     {sub [>BitsLeft],cl    ;Dec(BitsLeft, Bits)}
        $A0/>CurByte/          {mov al,[>CurByte]     ;ax = CurByte}
        $30/$E4/               {xor ah,ah}
        $BB/$01/$00/           {mov bx,1              ;bx = 1 shl Bits -1}
        $D3/$E3/               {shl bx,cl}
        $4B/                   {dec bx}
        $21/$C3/               {and bx,ax             ;uzReadBits = bx and CurByte}
        $89/$5E/<uzReadBits/   {mov [bp+<uzReadBits],bx}
        $D3/$E8/               {shr ax,cl             ;CurByte = CurByte shr Bits}
        $A2/>CurByte);         {mov [>CurByte],al}
    end
    else if (Bits = BitsLeft) then begin
      {return what we have}
      inline(
        $31/$C0/               {xor  ax,ax             ;ax = 0}
        $86/$06/>CurByte/      {xchg al,[>CurByte]     ;al = CurByte, CurByte = 0}
        $89/$46/<uzReadBits/   {mov  [bp+<uzReadBits],ax ;uzReadBits = CurByte}
        $88/$26/>BitsLeft);    {mov  [>BitsLeft],ah    ;BitsLeft = 0}
    end
    else begin
      {save what we have}
      SaveCurByte := CurByte;
      SaveBitsLeft := BitsLeft;

      {number of additional bits that we need}
      Delta := Bits-BitsLeft;

      {read next byte}
      uzReadNext;
      BitsLeft := 8;

      {make recursive call to read remaining bits; merge with saved bits}
      uzReadBits := (uzReadBits(Delta) shl SaveBitsLeft) or SaveCurByte;
    end;
  end;

  procedure UnZip.uzFlushOutputBuffer;
    {-Flush contents of output buffer}
  begin
    UpdateCRC(uzCrc, OutBuf^, OutPos);
    BlockWrite(OutF, OutBuf^, OutPos);
    arError := IoResult;
    if arError = ecOk then
      if not ShowProgress(OutSent, gCDH.OrigSize) then
        arError := ecUserAbort;
    if arError <> ecOk then
      InLeft := 0;
    OutPos := 0;
  end;

  procedure UnZip.uzWriteByte(B : Byte);
    {-Write one byte to the output stream}
  begin
    OutBuf^[OutPos] := B;
    Inc(OutSent);
    Inc(OutPos);
    if OutPos = SizeOf(OutBuf^) then
      uzFlushOutputBuffer;
  end;

  {--------- Stored files ----------}

  procedure UnZip.uzUnStore;
    {-Extract a stored file}
  var
    L : LongInt;
  begin
    repeat
      if InLeft > SizeOf(InBuf^) then
        L := SizeOf(InBuf^)
      else
        L := InLeft;
      BlockRead(arFile, InBuf^, L, InCnt);
      arError := IoResult;
      if arError = ecOk then begin
        UpdateCRC(uzCrc, InBuf^, InCnt);
        BlockWrite(OutF, InBuf^, InCnt);
        Inc(OutSent, InCnt);
        Dec(InLeft, InCnt);
        arError := IoResult;
        if arError = ecOk then
          if not ShowProgress(OutSent, gCDH.OrigSize) then
            arError := ecUserAbort;
      end;
    until (InLeft = 0) or (arError <> ecOk);
    OutPos := 0;
  end;

{---- Reduced files ---------------}

  function BitsNeeded(X : Byte) : Word;
    {-Calculate number of bits needed to encode the specified value}
  inline(
    $5B/                   {pop bx      ;BL = X-1}
    $4B/                   {dec bx}
    $31/$C0/               {xor ax,ax   ;AX = 0}
    $B9/$08/$00/           {mov cx,8    ;repeat at most 7 times}
                           {x1:}
    $40/                   {inc ax      ;increment bit count}
    $D0/$EB/               {shr bl,1    ;shift left most bit into CF}
    $E0/$FB);              {loopnz x1   ;repeat if <> 0}

  procedure UnZip.uzUnReduce;
    {-Extract a file that was reduced}
  label
    ExitPoint;
  const
    FactorMasks : array[1..4] of Byte = ($7F, $3F, $1F, $0F);
    DLE = 144;
  var
    C, Last : Byte;
    OpI : LongInt;
    OpO : LongInt;
    I, J, Sz : Integer;
    D : Word;
  begin
    if not GetMemCheck(Followers, SizeOf(Followers^)) then begin
      arError := ecOutOfMemory;
      Exit;
    end;

    Factor := gCDH.Method-1;
    FactorMask := FactorMasks[Factor];
    State := 0;
    C := 0;

    {load follower sets}
    for I := 255 downto 0 do begin
      Sz := uzReadBits(6);
      Followers^[I].Size := Sz;
      Dec(Sz);
      for J := 0 to Sz do
        Followers^[I].FSet[J] := uzReadBits(8);
    end;

    while (not InEof) and (OutSent < gCDH.OrigSize) do begin
      Last := C;
      with Followers^[Last] do
        if Size = 0 then
          C := uzReadBits(8)
        else begin
          C := uzReadBits(1);
          if C <> 0 then
            C := uzReadBits(8)
          else
            C := FSet[uzReadBits(BitsNeeded(Size))];
        end;

      if InEof then
        goto ExitPoint;

      case State of
        0 :
          if C <> DLE then
            uzWriteByte(C)
          else
            State := 1;
        1 :
          if C <> 0 then begin
            V := C;
            Len := V and FactorMask;
            if Len = FactorMask then
              State := 2
            else
              State := 3;
          end
          else begin
            uzWriteByte(DLE);
            State := 0;
          end;

        2 :
          begin
            Inc(Len, C);
            State := 3;
          end;

        3 :
          begin
            case Factor of
              1 : D := (V shr 7) and $01;
              2 : D := (V shr 6) and $03;
              3 : D := (V shr 5) and $07;
              4 : D := (V shr 4) and $0f;
            end;
            OpI := OutSent-(Swap(D)+C+1);

            if OpI >= SizeOf(OutBuf^) then
              OpO := OpI mod SizeOf(OutBuf^)
            else
              OpO := OpI;
            for I := 0 to Len+2 do begin
              if OpI < 0 then
                uzWriteByte(0)
              else
                uzWriteByte(OutBuf^[OpO]);
              Inc(OpI);
              Inc(OpO);
              if OpO >= SizeOf(OutBuf^) then
                OpO := 0;
            end;

            State := 0;
          end;
      end;
    end;

ExitPoint:
    FreeMemCheck(Followers, SizeOf(Followers^));
  end;

{------- Shrunk files ------------}

  procedure ClearHighBit(var I : Integer);
    {-Clear the high bit of I}
  inline(
    $5F/                   {pop di       ;ES:DI => I}
    $07/                   {pop es}
    $26/$81/$25/$FF/$7F);  {and word ptr es:[di],$7FFF}

  procedure SetHighBits(var FirstNode; Count : Word);
    {-Set the high bit of I}
  inline(
    $59/                   {pop cx       ;CX = Count}
    $5F/                   {pop di       ;ES:DI => I}
    $07/                   {pop es}
    $E3/$09/               {jcxz done}
                           {again:}
    $26/$81/$0D/$00/$80/   {or word ptr es:[di],$8000}
    $47/                   {inc di}
    $47/                   {inc di}
    $E2/$F7);              {loop again}
                           {done:}

  procedure ClearMarkedNodes(var FirstNode; Count : Word);
    {-Set all unmarked nodes to -1}
  inline(
    $59/                   {pop cx       ;CX = Count}
    $5F/                   {pop di       ;ES:DI => FirstNode}
    $07/                   {pop es}
    $FC/                   {cld          ;go forward}
    $E3/$0E/               {jcxz done}
                           {again:}
    $26/$8B/$05/           {mov ax,es:[di]}
    $A9/$00/$80/           {test ax,$8000}
    $74/$03/               {jz nope}
    $B8/$FF/$FF/           {mov ax,$FFFF}
                           {nope:}
    $AB/                   {stosw}
    $E2/$F2);              {loop again}
                           {done:}

  procedure UnZip.uzUnShrink;
    {-Extract a file that was shrunk}
  label
    ExitPoint;
  const
    MaxBits = 13;
    InitBits = 9;
    FirstFree = 257;
    Clear = 256;
    MaxCodeMax = 8192; {= 1 shl MaxBits}
  var
    CodeSize : Integer;
    MaxCode : Integer;
    NextFree : Integer;
    BaseChar : Integer;
    NewCode : Integer;
    OldCode : Integer;
    SaveCode : Integer;
    N, R : Integer;
  begin
    CodeSize := InitBits;
    MaxCode := (1 shl InitBits)-1;
    NextFree := FirstFree;

    SuffixTable := nil;
    Stack := nil;

    if not (
      GetMemCheck(PrefixTable, SizeOf(PrefixTable^)) and
      GetMemCheck(SuffixTable, SizeOf(SuffixTable^)) and
      GetMemCheck(Stack, SizeOf(Stack^)) ) then begin
        arError := ecOutOfMemory;
        goto ExitPoint;
    end;

    FillChar(PrefixTable^, SizeOf(PrefixTable^), $FF);
    for NewCode := 255 downto 0 do begin
      PrefixTable^[NewCode] := 0;
      SuffixTable^[NewCode] := NewCode;
    end;

    OldCode := uzReadBits(CodeSize);
    if InEof then
      goto ExitPoint;
    BaseChar := OldCode;

    uzWriteByte(BaseChar);

    StackIndex := 0;
    while (not InEof) do begin
      NewCode := uzReadBits(CodeSize);
      while (NewCode = Clear) and (not InEof) do begin
        case uzReadBits(CodeSize) of
          1 : begin
                Inc(CodeSize);
                if CodeSize = MaxBits then
                  MaxCode := MaxCodeMax
                else
                  MaxCode := (1 shl CodeSize)-1;
              end;
          2 : begin
                {mark all nodes as potentially unused}
                SetHighBits(PrefixTable^[FirstFree], NextFree-FirstFree);

                {unmark those used by other nodes}
                for N := FirstFree to NextFree-1 do begin
                  {reference to another node?}
                  R := PrefixTable^[N] and $7FFF;
                  {flag node as referenced}
                  if R >= FirstFree then
                    ClearHighBit(PrefixTable^[R]);
                end;

                {clear the ones that are still marked}
                ClearMarkedNodes(PrefixTable^[FirstFree], NextFree-FirstFree);

                {recalculate NextFree}
                NextFree := FirstFree;
                while (NextFree < MaxCodeMax) and (PrefixTable^[NextFree] <> -1) do
                  Inc(NextFree);
              end;
        end;

        NewCode := uzReadBits(CodeSize);
      end;

      if InEof then
        goto ExitPoint;

      {save current code}
      SaveCode := NewCode;

      {special case}
      if PrefixTable^[NewCode] = Unused then begin
        Stack^[StackIndex] := BaseChar;
        Inc(StackIndex);
        NewCode := OldCode;
      end;

      {generate output characters in reverse order}
      while (NewCode >= FirstFree) do begin
        if PrefixTable^[NewCode] = Unused then begin
          Stack^[StackIndex] := BaseChar;
          Inc(StackIndex);
          NewCode := OldCode;
        end else begin
          Stack^[StackIndex] := SuffixTable^[NewCode];
          Inc(StackIndex);
          NewCode := PrefixTable^[NewCode];
        end;
      end;

      BaseChar := SuffixTable^[NewCode];
      uzWriteByte(BaseChar);

      {put them out in forward order}
      while (StackIndex > 0) do begin
        Dec(StackIndex);
        uzWriteByte(Stack^[StackIndex]);
      end;

      {add new entry to tables}
      NewCode := NextFree;
      if NewCode < MaxCodeMax then begin
        PrefixTable^[NewCode] := OldCode;
        SuffixTable^[NewCode] := BaseChar;
        while (NextFree < MaxCodeMax) and (PrefixTable^[NextFree] <> Unused) do
          Inc(NextFree);
      end;

      {remember previous code}
      OldCode := SaveCode;
    end;

ExitPoint:
    FreeMemCheck(PrefixTable, SizeOf(PrefixTable^));
    FreeMemCheck(SuffixTable, SizeOf(SuffixTable^));
    FreeMemCheck(Stack, SizeOf(Stack^));
  end;

{---- Imploded files ---------}

  procedure ReverseBits(var W : Word);
    {-Reverse the order of the bits in W}
  Inline(
    $5F/                   {pop di       ;ES:DI => W}
    $07/                   {pop es}
    $26/                   {es:}
    $8B/$1D/               {mov bx,[di]  ;BX = W}
    $31/$C0/               {xor ax,ax    ;AX = 0}
    $B9/$10/$00/           {mov cx,16    ;repeat 16 times}
                           {x1:}
    $D1/$EB/               {shr bx,1     ;shift rightmost bit into CF}
    $D1/$D0/               {rcl ax,1     ;rotate CF into AX}
    $E2/$FA/               {loop x1      ;repeat}
    $AB);                  {stosw        ;W = AX}

  procedure SortLengths(var Tree : SfTree);
    {-Sort the bit lengths in ascending order, while retaining the order
      of the original lengths stored in the file}
  const
    XL : Integer = 0;
    XGL : Integer = 0;
    TXP  : SfEntryPtr = nil;
    TXGP : SfEntryPtr = nil;
  var
    X, Gap : Integer;
    Done : Boolean;
    LT : LongInt;
  begin
    Gap := Tree.Entries shr 1;
    repeat
      repeat
        Done := True;
        for X := 0 to (Tree.Entries-1)-Gap do begin
          TXP := @Tree.Entry[X];
          TXGP := @Tree.Entry[X+Gap];
          XL := TXP^.BitLength;
          XGL := TXGP^.BitLength;
          if (XL > XGL) or ((XL = XGL) and (TXP^.Value > TXGP^.Value)) then begin
            LT := TXP^.L;
            TXP^.L := TXGP^.L;
            TXGP^.L := LT;
            Done := False;
          end;
        end;
      until Done;

      Gap := Gap shr 1;
    until (Gap = 0);
  end;

  procedure UnZip.uzReadLengths(var T);
    {-Read bit lengths for a tree}
  var
    Tree : SfTree absolute T;
    TreeBytes : Integer;
    I, J, K : Integer;
    Num, Len : Integer;
    B : Byte;
  begin
    {get number of bytes in compressed tree}
    TreeBytes := uzReadBits(8)+1;

    I := 0;
    Tree.MaxLength := 0;

    {High nibble: Number of values at this bit length + 1.
     Low  nibble: Bits needed to represent value + 1}
    for J := 1 to TreeBytes do begin
      B := uzReadBits(8);
      Len := (B and $0F)+1;
      Num := (B shr 4)+1;

      for K := I to I+Num-1 do
        with Tree, Entry[K] do begin
          if Len > MaxLength then
            MaxLength := Len;
          BitLength := Len;
          Value := K;
        end;
      Inc(I, Num);

      Dec(TreeBytes);
    end;
  end;

  procedure GenerateTree(var Tree : SfTree);
    {-Generate a Shannon-Fano tree}
  var
    C : Word;
    CodeIncrement : Integer;
    LastBitLength : Integer;
    I : Integer;
  begin
    C := 0;
    CodeIncrement := 0;
    LastBitLength := 0;

    for I := Tree.Entries-1 downto 0 do
      with Tree.Entry[I] do begin
        Inc(C, CodeIncrement);
        if BitLength <> LastBitLength then begin
          LastBitLength := BitLength;
          CodeIncrement := 1 shl (16-LastBitLength);
        end;
        Code := C;
      end;
  end;

  procedure UnZip.uzLoadTree(var T; TreeSize : Integer);
    {-Load one Shannon-Fano tree}
  var
    I : Word;
    Tree : SfTree absolute T;
  begin
    Tree.Entries := TreeSize;
    uzReadLengths(Tree);
    SortLengths(Tree);
    GenerateTree(Tree);
    for I := 0 to TreeSize-1 do
      ReverseBits(Tree.Entry[I].Code);
  end;

  function UnZip.uzReadTree(var T) : Byte;
    {-Read next byte using a Shannon-Fano tree}
  const
    Bits : Integer = 0;
    CV   : Word = 0;
    E    : Integer = 0;
    Cur  : Integer = 0;
  var
    Tree : SfTree absolute T;
  begin
    uzReadTree := 0;
    Bits := 0;
    CV := 0;
    Cur := 0;
    E := Tree.Entries;

    repeat
      CV := CV or (uzReadBits(1) shl Bits);
      Inc(Bits);

      while Tree.Entry[Cur].BitLength < Bits do begin
        Inc(Cur);
        if Cur >= E then
          Exit;
      end;

      while Tree.Entry[Cur].BitLength = Bits do begin
        if Tree.Entry[Cur].Code = CV then begin
          uzReadTree := Tree.Entry[Cur].Value;
          Exit;
        end;

        Inc(Cur);
        if Cur >= E then
          Exit;
      end;
    until False;
  end;

  procedure UnZip.uzUnImplode;
    {-Extract an imploded file}
  label
    ExitPoint;
  const
    Length : Integer = 0;
    DI : Integer = 0;
  var
    DIndex : LongInt;
    Distance : Integer;
  begin
    {do we have an 8K dictionary?}
    if (gCDH.BitFlag and $02) <> 0 then
      DictBits := 7
    else
      DictBits := 6;

    {allocate trees}
    DistanceTree := nil;
    LitTree := nil;
    if not (
      GetMemCheck(LengthTree, SizeOf(LengthTree^)-(192*SizeOf(SfEntry))) and
      GetMemCheck(DistanceTree, SizeOf(DistanceTree^)-(192*SizeOf(SfEntry)))
      ) then begin
        arError := ecOutOfMemory;
        goto ExitPoint;
    end;

    {do we have a Literal tree?}
    if (gCDH.BitFlag and $04) <> 0 then begin
      if not GetMemCheck(LitTree, SizeOf(LitTree^)) then begin
        arError := ecOutOfMemory;
        goto ExitPoint;
      end;
      uzLoadTree(LitTree^, 256);
      MinMatchLength := 3;
    end
    else
      MinMatchLength := 2;

    {load the other two trees}
    uzLoadTree(LengthTree^, 64);
    uzLoadTree(DistanceTree^, 64);

    while (not InEof) and (OutSent < gCDH.OrigSize) do
      {is data literal?}
      if Boolean(uzReadBits(1)) then begin
        {if MinMatchLength = 3 then we have a Literal tree}
        if (MinMatchLength = 3) then
          uzWriteByte( uzReadTree(LitTree^) )
        else
          uzWriteByte( uzReadBits(8) );
      end
      else begin
        {data is a sliding dictionary}
        Distance := uzReadBits(DictBits);

        {using the Distance Shannon-Fano tree, read and decode the
         upper 6 bits of the Distance value}
        Distance := Distance or (uzReadTree(DistanceTree^) shl DictBits);

        {using the Length Shannon-Fano tree, read and decode the Length value}
        Length := uzReadTree(LengthTree^);
        if Length = 63 then
          Inc(Length, uzReadBits(8));
        Inc(Length, MinMatchLength);

        {move backwards Distance+1 bytes in the output stream, and copy
         Length characters from this position to the output stream.
         (if this position is before the start of the output stream,
         then assume that all the data before the start of the output
         stream is filled with zeros)}
        DIndex := OutSent-(Distance+1);
        DI := DIndex mod SizeOf(OutBuf^);
        while Length > 0 do begin
          if DI < 0 then
            uzWriteByte(0)
          else
            uzWriteByte(OutBuf^[DI]);
          Inc(DI);
          if DI >= SizeOf(OutBuf^) then
            DI := 0;
          Dec(Length);
        end;
      end;

ExitPoint:
    FreeMemCheck(LitTree, SizeOf(LitTree^));
    FreeMemCheck(LengthTree, SizeOf(LengthTree^)-(192*SizeOf(SfEntry)));
    FreeMemCheck(DistanceTree, SizeOf(DistanceTree^)-(192*SizeOf(SfEntry)));
  end;

  procedure UnZip.uzExtractFile(var Header : CentralDirHead; OutName : PathStr);
    {-Extract a single file}
  label
    ExitPoint;
  var
    FP : LongInt;
    I : Word;
    LH : LocalHeader;
    FName : PathStr;
  begin
    {reset internal variables}
    arError := ecOk;
    gCDH := Header;
    BitsLeft := 0;
    CurByte := 0;
    InCnt := 0;
    InLeft := gCDH.NewSize;
    InPos := 1+SizeOf(InBuf^);
    OutSent := 0;
    OutPos := 0;
    uzCrc := -1;
    InEof := False;
    InBuf := nil;
    OutBuf := nil;

    {make sure we know the compression method}
    if (Lo(gCDH.VersionNeeded) > MaxUnzipVer) or                       {!!.01}
       (gCDH.Method = cmcTokenized) or                                 {!!.01}
       (gCDH.Method > cmcDeflated) then begin                          {!!.01}
      arError := epNonFatal+ecUnknownMethod;
      Exit;
    end;

    {can't extract encrypted files}
    if gCDH.BitFlag and $0001 <> 0 then begin
      arError := epNonFatal+ecFileEncrypted;
      Exit;
    end;

    {try to allocate I/O buffers}
    if not ( GetMemCheck(OutBuf, SizeOf(OutBuf^)) and
             GetMemCheck(InBuf, SizeOf(InBuf^)) ) then begin
      arError := epFatal+ecOutOfMemory;
      goto ExitPoint;
    end;

    {save current file position}
    FP := FilePos(arFile);

    {move file pointer to start of compressed data}
    Seek(arFile, gCDH.LocalHeaderOfs+SizeOf(LongInt));
    uzReadLocalHeader(LH, FName);
    if arError <> ecOk then
      goto ExitPoint;

    {try to create output file}
    CreateOutputFile(OutF, OutName);
    if arError <> ecOk then begin
      case arError of
        ecPathNotFound, ecInvalidDrive, ecDiskFull, ecDriveNotReady : {};
        else arError := epNonFatal+ecCannotCreate;
      end;
      Seek(arFile, FP);
      I := IoResult;
      goto ExitPoint;
    end;

    {do it}
    case gCDH.Method of
      cmcStored :
        uzUnStore;
      cmcShrunk :
        uzUnShrink;
      cmcReduced1..cmcReduced4 :
        uzUnReduce;
      cmcImploded :
        uzUnImplode;
      cmcDeflated :                                                    {!!.01}
        uzInflateFile;                                                 {!!.01}
    end;

    {any bytes left in output buffer?}
    if OutPos > 0 then
      {flush output buffer and update CRC}
      uzFlushOutputBuffer;

    {set date/time stamp and close the file}
    SetFTime(OutF, MakeLongInt(gCDH.LastModDate, gCDH.LastModTime));
    Close(OutF);
    I := IoResult;
    if arError = ecOk then
      arError := I;
    if arError <> ecOk then
      Erase(OutF);
    I := IoResult;
    if arError = ecOk then
      arError := I;

    {reset file pointer}
    Seek(arFile, FP);
    I := IoResult;
    if arError = ecOk then
      arError := I;

    {check the CRC}
    if arError = ecOk then begin
      uzCrc := not uzCrc;
      if uzCrc <> gCDH.Crc then
        arError := epNonFatal+ecBadFileCRC;
    end;

ExitPoint:
    {dispose of buffers}
    FreeMemCheck(OutBuf, SizeOf(OutBuf^));
    FreeMemCheck(InBuf, SizeOf(InBuf^));
  end;

  function UnZip.OkToWrite(ZNP : ZipNodePtr; var FName : PathStr) : Boolean;
    {-Returns True if OK to write file associated with ZNP}
  begin
    if @uzOK <> nil then
      OkToWrite := uzOK(ZNP, FName, @Self)
    else
      OkToWrite := True;
  end;

  procedure UnZip.ShowComments(CP : CommentPtr; CLen : Word);
    {-Called to display name of zip file and zip file comments}
  begin
    if @uzShowZip <> nil then
      uzShowZip(CP, CLen, @Self);
  end;

  procedure UnZip.ShowMethod(ZNP : ZipNodePtr; FName : PathStr);
    {-Called to display name of file being unzipped and comp. method}
  begin
    if @uzShowMethod <> nil then
      uzShowMethod(ZNP, FName, @Self);
  end;

  function UnZip.ExtractSuccess(ZNP : ZipNodePtr; FName : PathStr) : Boolean;
    {-Called after file assoc. with ZNP has been unzipped}
  begin
    if @uzSuccess <> nil then
      ExtractSuccess := uzSuccess(ZNP, FName, @Self)
    else
      ExtractSuccess := (arError = ecOk);
  end;

  function UnZip.ShowProgress(BytesWritten, TotalBytes : LongInt) : Boolean;
    {-Called when flushing output buffer to disk}
  begin
    if @uzProgress <> nil then
      ShowProgress := uzProgress(@Self, BytesWritten, TotalBytes)
    else
      ShowProgress := True;
  end;

  procedure UnZip.SetOkToWriteFunc(OKF : OkToWriteFunc);
    {-Set OK to write function}
  begin
    uzOK := OKF;
  end;

  procedure UnZip.SetShowCommentsProc(SZCP : ShowCommentsProc);
    {-Set procedure to display zip file name and comments}
  begin
    uzShowZip := SZCP;
  end;

  procedure UnZip.SetShowMethodProc(SMP : ShowMethodProc);
    {-Set procedure to display file name and compression method}
  begin
    uzShowMethod := SMP;
  end;

  procedure UnZip.SetExtractSuccessFunc(ESF : ExtractSuccessFunc);
    {-Set procedure to call after file has been unzipped}
  begin
    uzSuccess := ESF;
  end;

  procedure UnZip.SetShowProgressFunc(SPF : ShowProgressFunc);
    {-Set procedure to call to show progress}
  begin
    uzProgress := SPF;
  end;
